<!DOCTYPE html>
<html lang="zn-Hans">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, maximum-scale=1" />
  <meta name="author" content="败给时间">
  <meta name="description" content="本篇文章会先介绍 工厂方法模式​ 的一些知识和特点，并在最后对 工厂方法模式 和 简单工厂模式 这二者之间的异同做一些分析">
  
  <meta property="og:title" content="工厂方法模式" />
<meta property="og:description" content="本篇文章会先介绍 工厂方法模式​ 的一些知识和特点，并在最后对 工厂方法模式 和 简单工厂模式 这二者之间的异同做一些分析" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://catcheroftime.github.io/blog/2020-10/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" />
<meta property="article:published_time" content="2020-10-29T22:15:00&#43;08:00"/>
<meta property="article:modified_time" content="2020-10-29T22:15:00&#43;08:00"/>


  <title>
  
       工厂方法模式 | 一个懒散的程序猿 
  
  </title>

  <link rel="canonical" href="https://catcheroftime.github.io/blog/2020-10/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">

  
  

  
  <link href="https://catcheroftime.github.io/css/vendors-extensions/fontawesome/all.min.css" rel="stylesheet">

  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:300,400,500,600">
  <link href="https://catcheroftime.github.io/css/font.css" rel="stylesheet"> 
    
  
  <link href="https://catcheroftime.github.io/css/vendors/bootstrap4/bootstrap.min.css" rel="stylesheet">
  <link href="https://catcheroftime.github.io/css/vendors-extensions/mdb/mdb.min.css" rel="stylesheet"> 
  <link href="https://catcheroftime.github.io/css/vendors/mdb/style.min.css" rel="stylesheet"> 
  <link href="https://catcheroftime.github.io/css/main.css" rel="stylesheet">


  
  <link rel="shortcut icon"
  
  >


  
  

  <style type="text/css">
      @media (min-width: 800px) and (max-width: 850px) {
              .navbar:not(.top-nav-collapse) {
                  background: #1C2331!important;
              }
          }
  </style>


  
    
    <link rel="stylesheet" href="https://catcheroftime.github.io/js/vendors/katex/katex.min.css">
  
  

  
    
    <link rel="stylesheet" href="https://catcheroftime.github.io/css/vendors/highlight/github-gist.css">
  

</head>

  <body class="bg-light" data-spy="scroll" data-target="#page-scrollspy" data-offset="90">
  
    
    

    
      


<nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
    <div class="container">

      
      <a class="navbar-brand" href="https://catcheroftime.github.io/">
          
        <strong> 败给时间</strong>
      </a>

      
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
        aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      
      <div class="collapse navbar-collapse" id="navbarSupportedContent">

        
        <ul class="navbar-nav mr-auto ">
          <li class="nav-item ">
            <a class="nav-link" href="https://catcheroftime.github.io/">Home</a>
          </li>
             
            <li class="nav-item ">
              <a class="nav-link" href="https://catcheroftime.github.io/blog/" >Blog  </a>
            </li>
          
             
            <li class="nav-item ">
              <a class="nav-link" href="https://catcheroftime.github.io/about/" >About  </a>
            </li>
          
          
        </ul>

      </div>

    </div>
  </nav>
  
 
      
 






<div id="site-header" class="carousel slide carousel-fade" data-ride="carousel" style="height: 18rem;" >  

  
  
  

  
  <div class="carousel-inner" role="listbox">
    
      

        
        <div class="carousel-item active">
          <div class="view" style="background-image: url('https://catcheroftime.github.io/img/header-slides/raw_1515691746.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

              
              
              

            </div>
            

          </div>
        </div>
        
      
    
      

        
        <div class="carousel-item">
          <div class="view" style="background-image: url('https://catcheroftime.github.io/img/header-slides//raw_1515847341.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

            

            </div>
            

          </div>
        </div>
        
      
    

  
  </div>
  

  
  <div class="carousel-content text-center white-text wow fadeIn">
    <div class="row mx-0 headfont mt-3 pt-4">
      
      <div class="col-12 col-sm-5 align-middle">
        <a href="https://catcheroftime.github.io/">
          
        </a>
      </div>
      
      <div class="col-12 col-sm-7 text-left pl-2">
        <a href="https://catcheroftime.github.io/">
          <h1 class="mb-2 h1" style="font-weight: 300;" >
            <strong>一个懒散的程序猿</strong>
          </h1>
        </a>
        

             
        <div class="mt-2" style="font-size: 1rem; color: white;">
            
              <a href="https://github.com/catcheroftime" target="_blank" rel="noopener"><i class="fab fa-github pr-1" aria-hidden="true"></i></a>    
            
            

            

            

            

            
    
            
    
        
            
                <a href="mailto:buptzhangwei@foxmail.com"><i class="far fa-envelope-open pr-1" aria-hidden="true"></i></a>
            
    
            

            
        </div>
      </div>
    </div>
  </div>
  

  
  
  

</div>
  
    

    
  
  <main class="post-main-wrapper">
    
    
    <div class="row">

      

      
      <div class="col-md-10">
      

        
        <div class="z-depth-1  post-wrapper white-bg single-post">

          <div class="post-header text-center" >
  <ul class="post-meta li-x">
    
      
        <li><a href="https://catcheroftime.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><i class="fas fa-folder-open pr-1" aria-hidden="true"></i> 设计模式 </a></li>
      
    
    
  </ul>

  <div class="px-4 post-heading">工厂方法模式</div>

  <ul class="post-meta li-x mt-1">
    
      <li>Oct 29, 2020</li>
    

    
  </ul>
  

</div>


          <div class="post-content markdown">
            <p>本篇文章会先介绍 <code>工厂方法模式​</code> 的一些知识和特点，并在最后对 <code>工厂方法模式</code> 和 <code>简单工厂模式</code> 这二者之间的异同做一些分析</p>

<h2 id="意图">意图</h2>

<p>先看一下 <code>GOF</code> 中是如何对 <code>工厂方式模式</code> 进行定义的：</p>

<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 工厂方法模式 <strong>使一个类的实例化延迟到其子类</strong></p>
</blockquote>

<p>所谓使一个类的实例化延迟到其子类，是因为抽象的 (工厂) 类不知道要实例化哪个具体 (产品) 类，所以实例化动作只能由具体的子 (工厂) 类去做, 抽象和具体 (工厂) 类中定义的、产生实例 (产品) 的接口函数，被我们成为 <code>工厂方法</code>，因为它负责 “生产” 一个对象</p>

<p><code>工厂方法模式</code> 简单点说就是解决接口没法直接 <code>new</code> 的问题, 而 <code>GOF</code> 中对其使用场景的描述，也举了一些例子：</p>

<ul>
<li>当一个类不知道它所必须创建的对象的类的时候</li>
<li>当一个类希望由它的子类来指定它所创建的对象的时候</li>
<li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候</li>
</ul>

<p>关于使用场景的第三点，我觉得这样解释可能更简单一点，具体的工厂类在创建实例的时候，具体创建哪个产品对象，这种一对一的信息，对抽象工厂类而言并没有必要知道，这些信息只是具体工厂类自己维护的局部信息，换句话说，我只要产品就行，工厂你怎么生产我不关心，生产的对象是叫 <code>A</code> 还是叫 <code>B</code> 我也不关心的, 只要你有我要的产品功能就行</p>

<p>说了这么多概念的东西，还是看一下 UML 图 (图片来自于《大话设计模式》) 对这个代码结构有个大致的了解</p>

<p><img src="https://catcheroftime.github.io/images/blog/designpatterns/factorymethod/UML.png" alt="UML" /></p>

<p>所以 <code>工厂方法模式</code> 的核心是下面几个点</p>

<ul>
<li>Creator（抽象工厂）：声明一个工厂方法，该方法返回一个 <code>Product</code> 类型的对象</li>
<li>ConcreteCreator（具体工厂）：重载工厂方法，返回和自己一一对应的具体产品实例</li>
<li>Product（抽象产品）：抽象产品的一些共同接口</li>
<li>ConcreteProduct（具体产品）：具体产品</li>
<li><strong>一个具体工厂对应一个具体产品</strong></li>
</ul>

<h2 id="优缺点">优缺点</h2>

<p>根据 UML 图可以得到以下几个有点：</p>

<ul>
<li>隐藏了构造的过程，通过具体工厂的接口直接就能获取产品对象，很好的对外层屏蔽了代码的复杂度</li>
<li>外层使用抽象的产品类，不关心具体的产品是什么，依赖于抽象，一定程度上减少了耦合</li>
<li>一个工厂对应一个产品，所以当我们需要添加新的产品时，只需要添加一个新的工厂和产品即可，在改动上满足符合开放-封闭原则</li>
</ul>

<p>当然也有缺陷：</p>

<ul>
<li>每新增一个产品，就需要增加一个对应的产品的具体工厂类，增加了代码的冗余度</li>
<li>一个工厂只能生产一个产品</li>
<li>当我们仅仅需要产品对象时，迫使创建工厂的子类</li>
</ul>

<h2 id="怎么写">怎么写</h2>

<p>还是以 <code>简单工厂模式</code> 里提到的加减乘除为例子</p>

<p>操作类的代码实现没变：</p>

<pre><code class="language-C++">class Operation
{
public:
    Operation():A(0), B(0){}
    virtual ~Operation(){}

    double GetA() const { return A; }
    double GetB() const { return B; }
    void SetA(double x) { A=x; }
    void SetB(double y) { B=y; }
    double virtual GetResult(){ return 0; }

private:
    double A, B;
};

class Add : public Operation
{
public:
    double GetResult()
    {
        return GetA()+GetB();
    }
};

class Sub : public Operation
{
public:
    double GetResult()
    {
        return GetA()-GetB();
    }
};

class Mul : public Operation
{
public:
    double GetResult()
    {
        return GetA()*GetB();
    }
};

class Div : public Operation
{
public:
    double GetResult()
    {
        if (GetB() == 0)
            throw string(&quot;Division by zero condition!&quot;);
        return GetA()/GetB();
    }
};
</code></pre>

<p>工厂类的实现如下：</p>

<pre><code class="language-C++">class Factory
{
public:
    virtual Operation *CreateOperator()=0;
};

class AddFactory : public Factory
{
public:
    Operation *CreateOperator() {
        return new Add();
    }
};

class SubFactory : public Factory
{
public:
    Operation *CreateOperator() {
        return new Sub();
    }
};

class MulFactory : public Factory
{
public:
    Operation *CreateOperator() {
        return new Mul();
    }
};

class DivFactory : public Factory
{
public:
    Operation *CreateOperator() {
        return new Div();
    }
};
</code></pre>

<p>main 函数调用的时候代码如下：</p>

<pre><code class="language-C++">#define SAFE_DELETE(p) { if(p) { delete p; p=nullptr;}}
int main()
{
    double A = 20;
    double B = 0;

    Factory *divFactory = new DivFactory();
    Operation *op = divFactory-&gt;CreateOperator();
    op-&gt;SetA(A);
    op-&gt;SetB(B);
    try {
        cout&lt;&lt; op-&gt;GetResult() &lt;&lt;endl;
    } catch (string exception ) {
        cout&lt;&lt; exception &lt;&lt;endl;
    }

    SAFE_DELETE(op);
    SAFE_DELETE(divFactory)
}
</code></pre>

<h2 id="工厂方法模式-和-简单工厂模式-的比较"><code>工厂方法模式</code> 和 <code>简单工厂模式</code> 的比较</h2>

<p>在网上很多资料上在整理这二者之间的区别时，一般都是这样认为的：</p>

<blockquote>
<p><code>工厂方法模式</code> 克服了 <code>简单工厂模式</code> 违背开放-封闭原则的缺点，是进一步抽象和推广。</p>
</blockquote>

<p>但是换个角度而言，<code>工厂方法模式</code> 中，一个具体工厂对应一个具体产品，等于说我写一个产品，就要实现一个工厂，这相对比较笨重，工厂和产品的关系是一对一管理，可是当我的需求变成产品比较固定且产品数量比较小的时候，我会更倾向于用一个工厂去管理所有的产品，而这恰恰就是 <code>简单工厂模式</code>， <code>简单工厂模式</code> 可能只是在需求场景变化时的一种进步，在这个场景下，虽然违背了开放-封闭原则，但是好像也无所谓了</p>

<p>而且在谈到违背 <code>开放-封闭原则</code> 的时候，我也有一些其他看法，如果加上客户端的代码一起来看的话，<code>工厂方法模式</code> 实现时，客户端需要决定实例化哪一个工厂来创建具体产品，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端来进行，你想要加新产品，本来是改工厂类的，而现在是修改客户端，不好说，不好说~</p>
          </div>

          
          <div class="row">
            <div class="col-md-8">
            
              <div class="mb-5">
                
<div class="li-x div-x post-meta">
  <li class="pr-0"><a href="https://catcheroftime.github.io/tags/"><i class="fas fa-tags"></i></a></li>
  <div class="tags-sm">
    
      <li><a href="https://catcheroftime.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" role="button">设计模式 </a></li>
      
    
  </div>
</div>
              </div>
            
            </div>
            
          </div>
          

          
          <div class="row pt-3">
            <div class="col-md-6">
              
                <a href=https://catcheroftime.github.io/blog/2020-10/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/ class="post-meta">
                  <div class="pt-2 pb-5 d-flex">
                    <i class="fas fa-angle-left text-grey font-weight-bold mr-2 active-color"></i>
                    <span>简单工厂模式</span>
                  </div>
                </a>
              
            </div>
            
            <div class="col-md-6 text-right" >
              
                <a href=https://catcheroftime.github.io/blog/2020-11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/ class="post-meta">
                  <div class="pt-2 pb-5 flex-reverse">
                    <i class="fas fa-angle-right text-grey font-weight-bold ml-2 active-color"></i>
                    <span>抽象工厂模式</span>
                  </div>
                </a>
              
            </div>
          </div>

          

        </div>
        

      </div>
      

      
	
	
	
	
		
		
		
	

		
		<div class="col-md-2 pl-0">

			
			<div id="page-scrollspy" class="toc-nav">
				
				<ul class="nav nav-pills ml-0">
					
					<li class="nav-item pb-3 text-center">
						<span class="font-weight-bold mb-2">- CATALOG - </span>
					</li>

					
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%84%8f%e5%9b%be">
												 意图
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">
												 优缺点
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%80%8e%e4%b9%88%e5%86%99">
												 怎么写
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f-%e5%92%8c-%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f-%e7%9a%84%e6%af%94%e8%be%83">
												 工厂方法模式 和 简单工厂模式 的比较
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 

				</ul>
			</div>
			

		</div>
		
	

    </div>
    


  </main>
  


    
    

<footer class="page-footer text-center font-small mt-4 wow fadeIn">


  
  <div class="pb-2 mt-5 pt-5">
    
      <a href="https://github.com/catcheroftime " target="_blank" rel="noopener"><i class="fab fa-github mr-3" aria-hidden="true"></i></a>    
    
    

    

    

    

    

    


    
        <a href="mailto:buptzhangwei@foxmail.com"><i class="far fa-envelope-open mr-3" aria-hidden="true"></i></a>
    

    

    

  </div>
  

  
  <div class="copyright py-4">
    
    <span>  2016 - 2020 &copy; | Theme <a href='https://github.com/orianna-zzo/AllinOne' target="_blank">AllinOne</a> by <a href='https://github.com/orianna-zzo' target="_blank">Orianna</a>  </span>
  </div>
  

</footer>


    






<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/jquery/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/jquery/jquery.smooth-scroll.min.js"></script>



<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/popper.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/holder.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors-extensions/bootstrap4/bootstrap.js" ></script>

<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/mdb/mdb.min.js"></script>

<script type="text/javascript" src="https://catcheroftime.github.io/js/main.js"></script>



  
  <script src="https://catcheroftime.github.io/js/vendors/highlight.pack.js"> </script>
  <script>hljs.initHighlightingOnLoad();</script>




 
  <script src="https://catcheroftime.github.io/js/vendors/katex/katex.min.js"> </script>
  <script src="https://catcheroftime.github.io/js/vendors/katex/contrib/auto-render.min.js"></script>

  <script>
      document.addEventListener("DOMContentLoaded", function () {
          renderMathInElement(document.body);
      });
  </script>








<script type="text/javascript">
  
  new WOW().init();
</script>




  </body>
</html>