<!DOCTYPE html>
<html lang="zn-Hans">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, maximum-scale=1" />
  <meta name="author" content="败给时间">
  <meta name="description" content="在上传头像过程中，经常会需要将图片裁切成指定的大小，给定一个指定大小的裁切框，调整裁切框位置裁切出理想的图片，今天在这里实现一个简单的图片裁切的应用">
  
  <meta property="og:title" content="Qt-图片裁切" />
<meta property="og:description" content="在上传头像过程中，经常会需要将图片裁切成指定的大小，给定一个指定大小的裁切框，调整裁切框位置裁切出理想的图片，今天在这里实现一个简单的图片裁切的应用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://catcheroftime.github.io/blog/2020-08/qt-%E5%9B%BE%E7%89%87%E8%A3%81%E5%88%87/" />
<meta property="article:published_time" content="2020-08-30T20:15:00&#43;08:00"/>
<meta property="article:modified_time" content="2020-08-30T20:15:00&#43;08:00"/>


  <title>
  
       Qt-图片裁切 | 一个懒散的程序猿 
  
  </title>

  <link rel="canonical" href="https://catcheroftime.github.io/blog/2020-08/qt-%E5%9B%BE%E7%89%87%E8%A3%81%E5%88%87/">

  
  

  
  <link href="https://catcheroftime.github.io/css/vendors-extensions/fontawesome/all.min.css" rel="stylesheet">

  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:300,400,500,600">
  <link href="https://catcheroftime.github.io/css/font.css" rel="stylesheet"> 
    
  
  <link href="https://catcheroftime.github.io/css/vendors/bootstrap4/bootstrap.min.css" rel="stylesheet">
  <link href="https://catcheroftime.github.io/css/vendors-extensions/mdb/mdb.min.css" rel="stylesheet"> 
  <link href="https://catcheroftime.github.io/css/vendors/mdb/style.min.css" rel="stylesheet"> 
  <link href="https://catcheroftime.github.io/css/main.css" rel="stylesheet">


  
  <link rel="shortcut icon"
  
  >


  
  

  <style type="text/css">
      @media (min-width: 800px) and (max-width: 850px) {
              .navbar:not(.top-nav-collapse) {
                  background: #1C2331!important;
              }
          }
  </style>


  
    
    <link rel="stylesheet" href="https://catcheroftime.github.io/js/vendors/katex/katex.min.css">
  
  

  
    
    <link rel="stylesheet" href="https://catcheroftime.github.io/css/vendors/highlight/github-gist.css">
  

</head>

  <body class="bg-light" data-spy="scroll" data-target="#page-scrollspy" data-offset="90">
  
    
    

    
      


<nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
    <div class="container">

      
      <a class="navbar-brand" href="https://catcheroftime.github.io/">
          
        <strong> 败给时间</strong>
      </a>

      
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
        aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      
      <div class="collapse navbar-collapse" id="navbarSupportedContent">

        
        <ul class="navbar-nav mr-auto ">
          <li class="nav-item ">
            <a class="nav-link" href="https://catcheroftime.github.io/">Home</a>
          </li>
             
            <li class="nav-item ">
              <a class="nav-link" href="https://catcheroftime.github.io/blog/" >Blog  </a>
            </li>
          
             
            <li class="nav-item ">
              <a class="nav-link" href="https://catcheroftime.github.io/about/" >About  </a>
            </li>
          
          
        </ul>

      </div>

    </div>
  </nav>
  
 
      
 






<div id="site-header" class="carousel slide carousel-fade" data-ride="carousel" style="height: 18rem;" >  

  
  
  

  
  <div class="carousel-inner" role="listbox">
    
      

        
        <div class="carousel-item active">
          <div class="view" style="background-image: url('https://catcheroftime.github.io/img/header-slides/raw_1515691746.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

              
              
              

            </div>
            

          </div>
        </div>
        
      
    
      

        
        <div class="carousel-item">
          <div class="view" style="background-image: url('https://catcheroftime.github.io/img/header-slides//raw_1515847341.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

            

            </div>
            

          </div>
        </div>
        
      
    

  
  </div>
  

  
  <div class="carousel-content text-center white-text wow fadeIn">
    <div class="row mx-0 headfont mt-3 pt-4">
      
      <div class="col-12 col-sm-5 align-middle">
        <a href="https://catcheroftime.github.io/">
          
        </a>
      </div>
      
      <div class="col-12 col-sm-7 text-left pl-2">
        <a href="https://catcheroftime.github.io/">
          <h1 class="mb-2 h1" style="font-weight: 300;" >
            <strong>一个懒散的程序猿</strong>
          </h1>
        </a>
        

             
        <div class="mt-2" style="font-size: 1rem; color: white;">
            
              <a href="https://github.com/catcheroftime" target="_blank" rel="noopener"><i class="fab fa-github pr-1" aria-hidden="true"></i></a>    
            
            

            

            

            

            
    
            
    
        
            
                <a href="mailto:buptzhangwei@foxmail.com"><i class="far fa-envelope-open pr-1" aria-hidden="true"></i></a>
            
    
            

            
        </div>
      </div>
    </div>
  </div>
  

  
  
  

</div>
  
    

    
  
  <main class="post-main-wrapper">
    
    
    <div class="row">

      

      
      <div class="col-md-10">
      

        
        <div class="z-depth-1  post-wrapper white-bg single-post">

          <div class="post-header text-center" >
  <ul class="post-meta li-x">
    
      
        <li><a href="https://catcheroftime.github.io/categories/qt"><i class="fas fa-folder-open pr-1" aria-hidden="true"></i> Qt </a></li>
      
    
    
  </ul>

  <div class="px-4 post-heading">Qt-图片裁切</div>

  <ul class="post-meta li-x mt-1">
    
      <li>Aug 30, 2020</li>
    

    
  </ul>
  
    <div class="view">
      <img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/cropPicture.png" />
    </div>
  

</div>


          <div class="post-content markdown">
            <p>在上传头像过程中，经常会需要将图片裁切成指定的大小，给定一个指定大小的裁切框，调整裁切框位置裁切出理想的图片，今天在这里实现一个简单的图片裁切的应用</p>

<h2 id="已实现功能简介">已实现功能简介</h2>

<p>为了方便演示，做了一个简单展示界面</p>

<p><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/cropPicture_show.png" alt="临时展示界面" /></p>

<p>目前我实现了以下一些功能：</p>

<ul>
<li>加载图片，并在图片上添加裁切框，右下角显示了裁切框大小</li>
<li>裁切框大小和位置均可调整，且在图片内部，不超出图片</li>
<li>裁切框中央颜色不变，裁切框外部颜色变深</li>
<li>裁切框内部的样式线条数可以配置</li>
<li>裁切框可以固定尺寸，或者设置放缩规则，等比(1:1)缩放或者自由缩放</li>
<li>按住键盘 <code>ctrl</code> 缩放为固定比例缩放， 按住键盘 <code>alt</code> 缩放为 1:1 长宽缩放<br /></li>
</ul>

<h2 id="整体代码思路">整体代码思路</h2>

<p>现在先简单解释一下实现的 demo 逻辑</p>

<ul>
<li>使用 <code>QLabel</code> 显示图片，我这里创建一个 <code>ImageShowLabel</code> 类来显示图片</li>
<li>在 <code>QLabel</code> 上添加一个 <code>QWidget</code> 作为裁切框， 在创建一个继承 <code>QWidget</code> 的 <code>CropBox</code> 类来表示裁切框</li>
<li>剩下的主要的就是裁切框 <code>CropBox</code> 大小位置，放缩等逻辑</li>
</ul>

<h2 id="imageshowlabel-的实现">ImageShowLabel 的实现</h2>

<p>先简单看一下头文件 imageshowlabel.h 定义的一些函数</p>

<pre><code>#include &lt;QLabel&gt;
#include &quot;cropbox.h&quot;

class QPixmap;
class ImageShowLabel : public QLabel
{
public:
    ImageShowLabel(QWidget *parent = 0);

    void setImage(const QPixmap &amp;image);
    QPixmap getCroppedImage();

    void setCropBoxLine(const int &amp; widthcount,const int&amp; heightcount);
    void setCropBoxShape(CropBox::CropBoxShape shape  = CropBox::Rect);
    void setCropBoxZoomMode(CropBox::ZoomMode mode  = CropBox::Free);  
    void setEnableKeyPressEvent(bool enabled);
    void setfixCropBox(const int &amp; width, const int&amp; height, bool fixed = true);

protected:
    void paintEvent(QPaintEvent *event);

private:
    CropBox * m_pCropBox;
    QPixmap m_orginalImg;
};
</code></pre>

<p><code>ImageShowLabel</code> 对象主要就是显示图片和返回裁切后的图片</p>

<ul>
<li>void setImage(const QPixmap &amp;image) 设置图片</li>
<li>QPixmap getCroppedImage(); 获取裁切框里的图片</li>
</ul>

<p>作为裁切框 <code>m_pCropBox</code> 父对象的它，此外也需要提供设置 <code>m_pCropBox</code> 对象的接口</p>

<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">void setCropBoxLine(const int &amp; widthcount,const int&amp; heightcount);</td>
<td align="left">设置 <code>m_pCropBox</code> 内部线条数</td>
</tr>

<tr>
<td align="left">void setCropBoxShape(CropBox::CropBoxShape shape  = CropBox::Rect);</td>
<td align="left">设置 <code>m_pCropBox</code> 的形状，是方形还是圆形</td>
</tr>

<tr>
<td align="left">void setCropBoxZoomMode(CropBox::ZoomMode mode  = CropBox::Free);</td>
<td align="left">设置 <code>m_pCropBox</code> 放缩的模式</td>
</tr>

<tr>
<td align="left">void setEnableKeyPressEvent(bool enabled)；</td>
<td align="left">设置 <code>m_pCropBox</code> 是否监听键盘事件</td>
</tr>

<tr>
<td align="left">void setfixCropBox(const int &amp; width, const int&amp; height, bool fixed = true);</td>
<td align="left">设置 <code>m_pCropBox</code> 是否固定大小</td>
</tr>
</tbody>
</table>

<p>这里只需要注意一点 void paintEvent(QPaintEvent *event); 函数的实现，这个函数需要实现裁切框内部高亮，外部变暗的功能</p>

<pre><code>//enum CropBoxShape {
//    Rect,
//    Round
//}; 

void ImageShowLabel::paintEvent(QPaintEvent *event)
{
    // 调用 QLabel 的 paintEvent 函数是为了绘制图片
    QLabel::paintEvent(event);

    QPainterPath border, cropbox;
    // 获取 ImageShowLabel 整体区域
    border.setFillRule(Qt::WindingFill);
    border.addRect(0, 0, this-&gt;width(), this-&gt;height());

    // 获取裁切框 m_pCropBox 形状，根据形状，确定阴影的样式
    cropbox.setFillRule(Qt::WindingFill);
    if (m_pCropBox-&gt;getCropBoxShape() == CropBox::Rect)
        cropbox.addRect(m_pCropBox-&gt;pos().x()+2,m_pCropBox-&gt;pos().y()+2, m_pCropBox-&gt;width()-4, m_pCropBox-&gt;height()-4);
    else
        cropbox.addEllipse(m_pCropBox-&gt;pos().x()+2,m_pCropBox-&gt;pos().y()+2, m_pCropBox-&gt;width()-4, m_pCropBox-&gt;height()-4);

    // 2者相减，得到裁切框外部的区域
    QPainterPath end_path = border.subtracted(cropbox);

    // 使用画笔，对这个区域简单加一层有一定透明度的遮罩
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing, true);
    painter.fillPath(end_path, QColor(0, 0, 0, 100));
}
</code></pre>

<p><code>ImageShowLabel</code> 这个类最主要就是这个 <code>paintEvent</code> 函数，我们可以得到如下的一个样式图，所以接下来主要就是绘制 <code>CropBox</code> 的样式</p>

<table><tr>
<td><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/label_paintround.png" width="90%"></td>
<td><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/label_paintrect.png" width="90%"></td>
</tr></table>

<h2 id="cropbox-的实现">CropBox 的实现</h2>

<p><code>CropBox</code> 实际上裁切框实现的类，这个类需要实现</p>

<ol>
<li>裁切框的样式

<ul>
<li>形状

<ul>
<li>圆形</li>
<li>方形</li>
</ul></li>
<li>背景，内部的线条，边框的线条，边框的一些标志点，以及裁切框大小的显示</li>
</ul></li>
<li>裁切框在图片内移动</li>
<li>裁切框在图片内放缩

<ul>
<li>8方向均可放缩，鼠标样式的修改</li>
<li>放缩的模式

<ul>
<li>自由放缩</li>
<li>固定比例放缩</li>
<li>1:1 放缩</li>
</ul></li>
</ul></li>
</ol>

<h3 id="裁切框的样式">裁切框的样式</h3>

<p>先看一下显示的样式图，我们结合样式图，来逐步解释代码的逻辑</p>

<table><tr>
<td><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/rect_demo.png" width="90%"></td>
<td><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/round_demo.png" width="90%"></td>
</tr></table>

<pre><code>void CropBox::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);
    QPainter painter(this);

    // 是否绘制内部的线条
    if (m_bDrawInternalLines)
        drawInternalLines(painter); 

    // 绘制边框
    drawBorder(painter);

    // 绘制一些边框上的点
    drawPoints(painter);

    // 显示裁切框大小
    drawSizeText(painter);
}
</code></pre>

<p>我又用网格图，绘制了一个大概的样式</p>

<p><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/style_demo.png" alt="样式demo" /></p>

<h4 id="绘制边框的-drawborder">绘制边框的 drawBorder</h4>

<pre><code>#define LINEWIDTH 1
#define SPACING   2 

enum CropBoxShape {
    Rect,
    Round
};

void CropBox::drawBorder(QPainter &amp;painter)
{
    // 绘制外边框线,外边框实线
    painter.setPen( QPen{QColor{3,125,203},SPACING});
    painter.drawRect( SPACING, SPACING, this-&gt;width()-SPACING*2,  this-&gt;height()-SPACING*2 );

    // 当形状是方形时，内边框线和外边框线是一样的，可以不用画
    // 当形状是圆形时，外边框不变，需要增加圆形的内边框线，内边框虚线
    if (m_shape == Round) {
        painter.setPen( QPen{QColor{255,255,255},LINEWIDTH,Qt::DashLine});
        painter.drawEllipse(SPACING, SPACING, this-&gt;width()-SPACING*2,  this-&gt;height()-SPACING*2 );
    }
}
</code></pre>

<h4 id="绘制边框上点的-drawpoints">绘制边框上点的 drawPoints</h4>

<pre><code>// 绘制外边框线上的几个标准点，我这边只画了8个，点缀一下
#define POINTSIZE 5
void CropBox::drawPoints(QPainter &amp;painter)
{
    painter.setPen( QPen{QColor{3,125,203},POINTSIZE});
    painter.drawPoint(SPACING,SPACING);
    painter.drawPoint(this-&gt;width()/2, SPACING);
    painter.drawPoint(this-&gt;width()-SPACING, SPACING);
    painter.drawPoint(SPACING, this-&gt;height()/2);
    painter.drawPoint(SPACING, this-&gt;height()-SPACING);
    painter.drawPoint(this-&gt;width()-SPACING, this-&gt;height()/2);
    painter.drawPoint(this-&gt;width()-SPACING, this-&gt;height()-SPACING);
    painter.drawPoint(this-&gt;width()/2, this-&gt;height()-SPACING);
}
</code></pre>

<h4 id="绘制内部线条的-drawinternallines">绘制内部线条的 drawInternalLines</h4>

<p>结合最开始的样例，内部的线条是虚线</p>

<pre><code>void CropBox::drawInternalLines(QPainter &amp;painter)
{
    // 需要先计算出，内部线条的绘画区域，方形和圆形是有区分
    QPainterPath cropbox_path;
    if (m_shape == Round)
        cropbox_path.addEllipse(SPACING, SPACING, this-&gt;width()-SPACING*2,  this-&gt;height()-SPACING*2);
    else
        cropbox_path.addRect(SPACING, SPACING, this-&gt;width()-SPACING*2,  this-&gt;height()-SPACING*2);

    // 设置被限制的绘画区域
    painter.setClipPath(cropbox_path);
    painter.setClipping(true);

    // 绘画内部虚线线条
    painter.setPen( QPen{QColor{230,230,230},LINEWIDTH,Qt::DashLine});
    for (int i=1; i&lt;m_widthCount; i++) {
        int width = this-&gt;width() / m_widthCount;
        painter.drawLine( i*width,  SPACING , i*width , this-&gt;height()-SPACING);
    }

    for (int i=1; i&lt;m_heightCount; i++) {
        int heigth = this-&gt;height()/ m_heightCount;
        painter.drawLine( SPACING ,i*heigth,   this-&gt;width()- SPACING, i*heigth);
    }

    // 绘画完，取消被限制的区域
    painter.setClipping(false);
}
</code></pre>

<h4 id="绘制裁切框大小-drawsizetext">绘制裁切框大小 drawSizeText</h4>

<pre><code>void CropBox::drawSizeText(QPainter &amp;painter)
{
    painter.setPen( QPen{QColor{255,0,0}});
    // 设置显示的内容，绘制Text 的区域， 字体呈现的对齐方式
    QString showText = QString(&quot;(&quot;) + QString::number(this-&gt;width()) + &quot;,&quot; + QString::number(this-&gt;height()) + &quot;)&quot;;
    QPointF topleft{(qreal)this-&gt;width()-(qreal)m_minWidth, (qreal)this-&gt;height()-(qreal)20};
    QSizeF size{(qreal)m_minWidth,20};
    QRectF position {topleft, size};
    QTextOption option{Qt::AlignVCenter | Qt::AlignRight };
    painter.drawText(position, showText, option);
}
</code></pre>

<h3 id="裁切框的移动">裁切框的移动</h3>

<p>移动这个功能的操作是：裁切框接收到鼠标左击事件，鼠标不松开的前提下移动鼠标，裁切框随鼠标移动，鼠标松开时，移动停止<br />
为了确保鼠标移动事件的捕获，<code>CropBox</code> 初始化中需要添加 <code>this-&gt;setMouseTracking(true);</code><br />
所以窗口移动主要就涉及到以下3个函数</p>

<pre><code>void mousePressEvent(QMouseEvent *event);
void mouseMoveEvent(QMouseEvent *event);
void mouseReleaseEvent(QMouseEvent *event);
</code></pre>

<p>但是移动过程中有个细节需要注意，裁切框不能移动到图像外侧，需要对移动的位置进行判断，所以将判断移动到另外一个函数中</p>

<pre><code>void handleMove(QPoint mouse_globalpos);
</code></pre>

<h4 id="mousepressevent">mousePressEvent</h4>

<p>鼠标点击的时候，需要记录一下点击的状态 <code>m_bMovingFlag=true</code> ，移动过程中，需要判断是否点击了，鼠标松开时， 设置 <code>m_bMovingFlag=false</code><br />
于此同时，需要记录2个点坐标，裁切框初始的位置 <code>this-&gt;pos()</code> ，以及鼠标的全局坐标 <code>event-&gt;globalPos()</code></p>

<p>那么在移动过程中裁切框的实时位置计算公式是 <code>移动过程中鼠标实时全局坐标 - 鼠标点击时的全局坐标 + 鼠标点击时的初始位置</code>, 为了方便， 所以点击的时候，记录了 <code>鼠标点击时的全部坐标-鼠标点击时的初始位置</code> 的值，也就是 <code>m_dragPosition = event-&gt;globalPos() - this-&gt;pos();</code> 这样移动过程中，只需要用  <code>移动过程中鼠标的实时全局坐标- m_dragPosition</code> 即可</p>

<pre><code>void CropBox::mousePressEvent(QMouseEvent *event)
{
    if (event-&gt;button() == Qt::LeftButton) {
        m_bMovingFlag = true;
        m_dragPosition = event-&gt;globalPos() - this-&gt;pos();
    }
    event-&gt;accept();
}
</code></pre>

<h4 id="mousemoveevent">mouseMoveEvent</h4>

<p>因为裁切框有移动和放缩的功能，所以鼠标在移动过程中，需要做一些额外的处理</p>

<ul>
<li>未点击状态下的鼠标移动时，当鼠标在裁切框边缘时，根据鼠标的位置，对鼠标样式进行对应的调整(8方向的鼠标设置)

<ul>
<li>非边缘位置，鼠标样式为正常指针样式</li>
<li>边缘位置，根据上下左右单独设置样式</li>
</ul></li>
<li>点击状态下，需要根据点击的位置，也就是鼠标的样式，区分是移动还是放缩</li>
</ul>

<p>代码如下：</p>

<pre><code>void CropBox::mouseMoveEvent(QMouseEvent *event)
{
    // event-&gt;pos() 获取的坐标是鼠标相对于裁切框的坐标
    QPoint point = event-&gt;pos();
    // 将这个坐标转换成相对于父对象的坐标，位置后放缩判断做准备
    QPoint parent_point = mapToParent(point);
    QPoint global_point = event-&gt;globalPos();

    if (!m_bMovingFlag) {
        setDirection(point);
    } else {
        if (m_curDirec == NONE)
            handleMove(global_point);
        else
            handleResize(parent_point);
    }

    event-&gt;accept();
}
</code></pre>

<h4 id="mousereleaseevent">mouseReleaseEvent</h4>

<pre><code>void CropBox::mouseReleaseEvent(QMouseEvent *event)
{
    this-&gt;setCursor(QCursor(Qt::ArrowCursor));
    if(event-&gt;button()==Qt::LeftButton)
        m_bMovingFlag = false;

    event-&gt;accept();
}
</code></pre>

<h4 id="handlemove">handleMove</h4>

<p>因为需要裁切框在图片内部移动，所以需要获取图片的坐标， 由于是使用 <code>QLabel</code> 来展示图片， <code>QLabel</code> 的大小其实就是裁切框移动的范围</p>

<p><code>void move(const QPoint &amp;);</code> 参数的值是相对于父对象的坐标</p>

<pre><code>void CropBox::handleMove(QPoint mouse_globalpos)
{
    QWidget* parent_widget = (QWidget *)this-&gt;parent();
    QPoint end_point = mouse_globalpos - m_dragPosition ;
    if (parent_widget) {
        // 保证最后移动到的位置是图片内部的位置，不超出图片
        int new_x = judgePosition(end_point.x(), 0, parent_widget-&gt;width()-this-&gt;width());
        end_point.setX(new_x);

        int new_y = judgePosition(end_point.y(), 0, parent_widget-&gt;height()-this-&gt;height());
        end_point.setY( new_y );
    }
    move( end_point );
}

inline int CropBox::judgePosition(int origin, int min, int max)
{
    if (origin &lt; min)  return min;
    if (origin &gt; max)  return max;
    return origin;
}
</code></pre>

<h3 id="放缩">放缩</h3>

<p>放缩主要分为2部分</p>

<ul>
<li>为了美观设置鼠标的样式, 8方向</li>
<li>实现放缩功能，并且放缩模式分为自由放缩，固定比例放缩，1:1放缩 （首先需要明确一点<code>1：1放缩</code> 就是裁切框一直保持是一个正方形，也就是长宽比是 <strong>1</strong>， 而 <code>固定长宽比</code> 此时的长宽比是任意值）</li>
<li>键盘控制放缩的模式</li>
</ul>

<p>定义鼠标的位置， 8方向外加一个中央位置的 <code>NONE</code></p>

<pre><code>enum Direction { UP=0, DOWN, LEFT, RIGHT, LEFTTOP, LEFTBOTTOM, RIGHTBOTTOM, RIGHTTOP, NONE };
</code></pre>

<p>定义放缩模式的枚举</p>

<pre><code>enum ZoomMode {
    Free,
    FixedRatio,
    Square,
};
</code></pre>

<h4 id="放缩的鼠标样式">放缩的鼠标样式</h4>

<p>这一部分主要就是判断鼠标当前的位置距离裁切框的位置，然后设置成对应的鼠标样式</p>

<pre><code>// 判断的阈值
#define PADDING 2 
void CropBox::setDirection(QPoint point)
{
    // 固定尺寸时，不存在放缩功能，不需要设置鼠标样式
    if (m_bFixSized) {
        m_curDirec = NONE;
        this-&gt;setCursor(QCursor(Qt::ArrowCursor));
        return;
    }

    int width = this-&gt;width();
    int heigth = this-&gt;height();

    if ( PADDING &gt;= point.x() &amp;&amp; 0 &lt;= point.x() &amp;&amp;  PADDING  &gt;= point.y() &amp;&amp; 0 &lt;= point.y())
    {
        m_curDirec = LEFTTOP;
        this-&gt;setCursor(QCursor(Qt::SizeFDiagCursor));
    }
    else if(width - PADDING &lt;= point.x() &amp;&amp; width &gt;= point.x() &amp;&amp; heigth - PADDING &lt;= point.y() &amp;&amp; heigth &gt;= point.y())
    {
        m_curDirec = RIGHTBOTTOM;
        this-&gt;setCursor(QCursor(Qt::SizeFDiagCursor));
    }
    else if(PADDING &gt;= point.x() &amp;&amp; 0 &lt;= point.x() &amp;&amp; heigth - PADDING &lt;= point.y() &amp;&amp; heigth &gt;= point.y())
    {
        m_curDirec = LEFTBOTTOM;
        this-&gt;setCursor(QCursor(Qt::SizeBDiagCursor));
    }
    else if(PADDING &gt;= point.y() &amp;&amp; 0 &lt;= point.y() &amp;&amp; width - PADDING &lt;= point.x() &amp;&amp; width &gt;= point.x())
    {
        m_curDirec = RIGHTTOP;
        this-&gt;setCursor(QCursor(Qt::SizeBDiagCursor));
    }
    else if(PADDING &gt;= point.x() &amp;&amp; 0 &lt;= point.x())
    {
        m_curDirec = LEFT;
        this-&gt;setCursor(QCursor(Qt::SizeHorCursor));
    }
    else if(PADDING &gt;= point.y() &amp;&amp; 0 &lt;= point.y())
    {
        m_curDirec = UP;
        this-&gt;setCursor(QCursor(Qt::SizeVerCursor));
    }
    else if(width - PADDING &lt;= point.x() &amp;&amp; width &gt;= point.x())
    {
        m_curDirec = RIGHT;
        this-&gt;setCursor(QCursor(Qt::SizeHorCursor));
    }
    else if(heigth - PADDING &lt;= point.y() &amp;&amp; heigth &gt;= point.y())
    {
        m_curDirec = DOWN;
        this-&gt;setCursor(QCursor(Qt::SizeVerCursor));
    }
    else
    {
        m_curDirec = NONE;
        this-&gt;setCursor(QCursor(Qt::ArrowCursor));
    }
}
</code></pre>

<h4 id="放缩逻辑">放缩逻辑</h4>

<p>放缩分为8方向，对应每个方向有单独的放缩规则，所以封装成对应的处理函数，在函数里在根据放缩的模式进行放缩</p>

<p>通过 <code>this-&gt;geometry();</code> 获取裁切框的几何形状 <code>QRect rectMove</code>, 而在放缩过程中：</p>

<ul>
<li>上，下，左， 右这4个方向放缩，对于裁切框而言只是需要修改 <code>QRect rectMove</code> 对应的上，下，左，右 的值</li>
<li>左上， 右上，右下，左下 这4个方向放缩的时候，也是一样， 修改 <code>QRect rectMove</code> 对应方向的2个值</li>
<li>最后将新的几何形状重新赋予裁切框 <code>this-&gt;setGeometry(rectMove);</code>即可实现放缩功能</li>
</ul>

<p>大致的代码逻辑如下：</p>

<pre><code>void CropBox::handleResize(QPoint mouse_parentpos)
{
    if (!m_bMovingFlag)
        return;

    // 记录当前的
    QRect rectMove = this-&gt;geometry();

    // 当鼠标移出图像外侧时，对放缩使用的坐标进行修正，这里只对最大值进行了修正，最小值，因为方向的问题，需要交给对应方向放缩的函数处理
    QPoint valid_point{mouse_parentpos} ;
    QWidget* parent_widget = (QWidget *)this-&gt;parent();
    valid_point.setX( judgePosition(valid_point.x(), 0, parent_widget-&gt;width()) );
    valid_point.setY( judgePosition(valid_point.y(), 0, parent_widget-&gt;height()) );

    switch(m_curDirec) {
    case UP:
        handleResizeUp(valid_point, rectMove, parent_widget);
        break;
    case DOWN:
        handleResizeDown(valid_point, rectMove, parent_widget);
        break;
    case LEFT:
        handleResizeLeft(valid_point, rectMove, parent_widget);
        break;
    case RIGHT:
        handleResizeRight(valid_point, rectMove, parent_widget);
        break;
    case RIGHTTOP:
        handleResizeRightTop(valid_point, rectMove, parent_widget);
        break;
    case RIGHTBOTTOM:
        handleResizeRightBottom(valid_point, rectMove, parent_widget);
        break;
    case LEFTTOP:
        handleResizeLeftTop(valid_point, rectMove, parent_widget);
        break;
    case LEFTBOTTOM:
        handleResizeLeftBottom(valid_point, rectMove, parent_widget);
        break;
    default:
        break;
    }

    this-&gt;setGeometry(rectMove);
}
</code></pre>

<p>8个方向处理放缩其实本质是一致的，都是计算新的几何形状，所以只举2个例子</p>

<h4 id="以向上为例-handleresizeup">以向上为例 handleResizeUp</h4>

<p><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/resizeup.gif" alt="向上改变形状" /></p>

<p>如图，最大值在传入该函数的时候就做了限制，所以该函数做了此方向上的最小值判断</p>

<ul>
<li>当放缩方式是 <code>自由</code> 放缩的时候，等于只要改变几何形状的 <code>上</code> 的值</li>
<li>当放缩方式是 <code>1:1</code> 或者<code>固定长宽比</code> 放缩的时候，此时长宽同时变化，所有直接调用 <code>handleResizeRightTop()</code> 函数，此时 向上放缩 等同于 向右上放缩，这个是我自己规定的，可以根据实际自己定义<br /></li>
</ul>

<p>所以代码如下：</p>

<pre><code>void CropBox::handleResizeUp(QPoint &amp;valid_point, QRect &amp;rectNew, const QWidget *parent_widget)
{
    if (m_zoomMode !=  Free) {
        handleResizeRightTop(valid_point, rectNew, parent_widget);
        return;
    }

    if (rectNew.bottom() - valid_point.y() + 1  &lt;= m_minHeight)
        valid_point.setY( rectNew.bottom() - m_minHeight + 1);

    rectNew.setTop( valid_point.y() );
}
</code></pre>

<p>这里有个坑 <code>rectNew.bottom() - valid_point.y() + 1  &lt;= m_minHeight</code> 计算长度的时候 +1， 之前缩放到最小高度的时候，例如80时，裁切框得到的最小高度永远是 81，查看 Qt 的文档时，可以看到这样文档描述</p>

<p><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/qrect.png" alt="QRect" /></p>

<p>大致意思就是，因为历史原因</p>

<pre><code>right() - left() + 1 = width()
bottom() - top() + 1 = height()
</code></pre>

<h4 id="以右上为例-handleresizerighttop">以右上为例 handleResizeRightTop</h4>

<p><img src="https://catcheroftime.github.io/images/blog/qt_plugin/cropimage/resize_rightup.gif" alt="向右上改变形状" /></p>

<ul>
<li>当放缩时 <code>自由</code> 放缩的时候，此时等于是同时改变几何形状的 <code>右</code> 和 <code>上</code> 的， 一样判断最小值</li>
<li>当放缩方式是 <code>1：1</code> 或者 <code>固定长宽比</code> 放缩时，难点依旧是对于如何不让裁切框出边界的问题</li>
</ul>

<p>再次强调一下 <code>1：1放缩</code> 就是裁切框一直保持是一个正方形，也就是长宽比是 <strong>1</strong>， 而 <code>固定长宽比</code> 此时的长宽比是任意值，所以可以使用 <code>m_heightwidthRatio</code> 值记录放缩前的长宽比<br />
并且此时放缩的长宽的最小值会跟用户设置的最小值是有出入的，长或宽在长宽比限制的情况下，很难同时到达最小点 (除非用户设置的最小值长宽比和放缩时的长宽比一样)，所以需要单独记录</p>

<pre><code>m_ratioMinWidth = m_minWidth * m_heightwidthRatio &gt; m_minHeight? m_minWidth : m_minHeight / m_heightwidthRatio;
m_ratioMinHeight = m_minWidth * m_heightwidthRatio &gt; m_minHeight? m_minWidth * m_heightwidthRatio : m_minHeight;
</code></pre>

<ul>
<li>先将鼠标的位置转换成合理的图像内的坐标</li>
<li>使用鼠标某个方向上的坐标得出 长或者宽，根据长宽比反推出 宽或者长</li>
<li>然后在判断新的 几何形状 是否在图像的内部

<ul>
<li>满足，直接设置新的 几何形状</li>
<li>不满足，重新计算一下新的 几何形状</li>
</ul></li>
</ul>

<p>代码如下：</p>

<pre><code>void CropBox::handleResizeRightTop(QPoint &amp;valid_point, QRect &amp;rectNew, const QWidget *parent_widget)
{
    if (m_zoomMode !=  Free) {
        if (valid_point.x() - rectNew.left() + 1 &lt;= m_ratioMinWidth)
            valid_point.setX( rectNew.left() + m_ratioMinWidth - 1);

        if (rectNew.bottom() - valid_point.y() + 1 &lt;= m_ratioMinHeight)
            valid_point.setY( rectNew.bottom() - m_ratioMinHeight + 1);

        int right = (rectNew.bottom()- valid_point.y() + 1)/m_heightwidthRatio + rectNew.left() - 1 ;
        if ( right &gt; parent_widget-&gt;width() ) {
            right = parent_widget-&gt;width();
            valid_point.setY( rectNew.bottom() - (parent_widget-&gt;width() - rectNew.left() + 1)*m_heightwidthRatio + 1 );
        }

        valid_point.setX( right );
    } else {
        if (valid_point.x() - rectNew.left() + 1 &lt;= m_minWidth)
            valid_point.setX( rectNew.left() + m_minWidth - 1);

        if (rectNew.bottom() - valid_point.y() + 1 &lt;= m_minHeight )
            valid_point.setY( rectNew.bottom() - m_minHeight + 1 );

    }

    rectNew.setRight(valid_point.x());
    rectNew.setTop(valid_point.y());
}
</code></pre>

<h4 id="结合键盘按键放缩">结合键盘按键放缩</h4>

<ul>
<li><code>ctrl</code> 固定比例放缩</li>
<li><code>alt</code> 1:1 放缩</li>
</ul>

<p><code>CropBox</code> 初始化的时候需要监听键盘事件 <code>this-&gt;setEnableKeyPressEvent(true);</code></p>

<p>代码如下：</p>

<pre><code>void CropBox::keyPressEvent(QKeyEvent *event)
{
    // m_keyPressZoomMode 记录按键前原始的放缩模式
    m_keyPressZoomMode = m_zoomMode;

    if (event-&gt;key() == Qt::Key_Control) {
        this-&gt;setZoomMode(FixedRatio);
        return;
    } else if(event-&gt;key() == Qt::Key_Alt) {
        this-&gt;setZoomMode(Square);
        return;
    } else {
        QWidget::keyPressEvent(event);
    }
}

void CropBox::keyReleaseEvent(QKeyEvent *event)
{
    if (event-&gt;key() == Qt::Key_Control || event-&gt;key() == Qt::Key_Alt) {
        this-&gt;setZoomMode(m_keyPressZoomMode);
        return;
    }

    QWidget::keyPressEvent(event);
}
</code></pre>

<h3 id="需要优化的地方">需要优化的地方</h3>

<h4 id="图片尺寸过大">图片尺寸过大</h4>

<p>当图片尺寸过大（超过了显示器的分辨率），<code>ImageShowLabel</code> 会显示不下，想到了以下2种解决方法</p>

<ul>
<li>使用一个 <code>QScrollArea</code> 包含了 <code>ImageShowLabel</code>, 这样会出现滑动轴，通过拖动来保证可以展示完整。</li>
<li>限制用户输入图片的大小</li>
</ul>

<p>这2种方法感觉都不是很好</p>

<h4 id="计算放缩后的几何形状的坐标">计算放缩后的几何形状的坐标</h4>

<p>因为使用 <code>QRect</code> 的 <code>right()</code>, <code>left()</code>, <code>top()</code> , <code>bottom()</code> 这些函数，导致计算过程中总是出现 +1，-1 的代码, 但是改变形状，可以直接调用对应的 set 函数就能直接改变形状;</p>

<p>官方推荐的方法中 <code>x()</code>, <code>width()</code>, <code>y()</code>, <code>height()</code> 等计算有效范围会简洁很多，但是设置新的形状的时候，需要设置 <code>x()</code>, <code>width()</code>, <code>y()</code>, <code>height()</code>， 设置起来更麻烦了</p>

<p>例如向上放缩的函数 <code>handleResizeUp</code></p>

<pre><code>void CropBox::handleResizeUp(QPoint &amp;valid_point, QRect &amp;rectNew, const QWidget *parent_widget)
{
    if (m_zoomMode !=  Free) {
        handleResizeRightTop(valid_point, rectNew, parent_widget);
        return;
    }

    int oldHeight = rectNew.height();
    int oldY = rectNew.y();
    if ( oldY + oldHeight - valid_point.y() &lt;= m_minHeight)
        valid_point.setY( oldY + oldHeight- m_minHeight);

    rectNew.setY( valid_point.y() );
    rectNew.setHeight( oldY + oldHeight - valid_point.y() );
}
</code></pre>

<h2 id="代码地址">代码地址</h2>

<p>github 地址 ：<a href="https://github.com/catcheroftime/CropPicture">https://github.com/catcheroftime/CropPicture</a></p>
          </div>

          
          <div class="row">
            <div class="col-md-8">
            
              <div class="mb-5">
                
<div class="li-x div-x post-meta">
  <li class="pr-0"><a href="https://catcheroftime.github.io/tags/"><i class="fas fa-tags"></i></a></li>
  <div class="tags-sm">
    
      <li><a href="https://catcheroftime.github.io/tags/qt" role="button">Qt </a></li>
      
    
      <li><a href="https://catcheroftime.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6" role="button">自定义插件 </a></li>
      
    
  </div>
</div>
              </div>
            
            </div>
            
          </div>
          

          
          <div class="row pt-3">
            <div class="col-md-6">
              
                <a href=https://catcheroftime.github.io/blog/2020-08/qt-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%B3%E4%B8%8B%E8%A7%92%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF%E5%BC%B9%E7%AA%97/ class="post-meta">
                  <div class="pt-2 pb-5 d-flex">
                    <i class="fas fa-angle-left text-grey font-weight-bold mr-2 active-color"></i>
                    <span>Qt-自定义右下角提示信息弹窗</span>
                  </div>
                </a>
              
            </div>
            
            <div class="col-md-6 text-right" >
              
                <a href=https://catcheroftime.github.io/blog/2020-09/qinputdialog%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/ class="post-meta">
                  <div class="pt-2 pb-5 flex-reverse">
                    <i class="fas fa-angle-right text-grey font-weight-bold ml-2 active-color"></i>
                    <span>QInputDialog源码分析(上)</span>
                  </div>
                </a>
              
            </div>
          </div>

          

        </div>
        

      </div>
      

      
	
	
	
	
		
		
		
	

		
		<div class="col-md-2 pl-0">

			
			<div id="page-scrollspy" class="toc-nav">
				
				<ul class="nav nav-pills ml-0">
					
					<li class="nav-item pb-3 text-center">
						<span class="font-weight-bold mb-2">- CATALOG - </span>
					</li>

					
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%b7%b2%e5%ae%9e%e7%8e%b0%e5%8a%9f%e8%83%bd%e7%ae%80%e4%bb%8b">
												 已实现功能简介
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%95%b4%e4%bd%93%e4%bb%a3%e7%a0%81%e6%80%9d%e8%b7%af">
												 整体代码思路
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#imageshowlabel-%e7%9a%84%e5%ae%9e%e7%8e%b0">
												 ImageShowLabel 的实现
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#cropbox-%e7%9a%84%e5%ae%9e%e7%8e%b0">
												 CropBox 的实现
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e8%a3%81%e5%88%87%e6%a1%86%e7%9a%84%e6%a0%b7%e5%bc%8f">
												 裁切框的样式
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e7%bb%98%e5%88%b6%e8%be%b9%e6%a1%86%e7%9a%84-drawborder">
												 绘制边框的 drawBorder
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e7%bb%98%e5%88%b6%e8%be%b9%e6%a1%86%e4%b8%8a%e7%82%b9%e7%9a%84-drawpoints">
												 绘制边框上点的 drawPoints
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e7%bb%98%e5%88%b6%e5%86%85%e9%83%a8%e7%ba%bf%e6%9d%a1%e7%9a%84-drawinternallines">
												 绘制内部线条的 drawInternalLines
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e7%bb%98%e5%88%b6%e8%a3%81%e5%88%87%e6%a1%86%e5%a4%a7%e5%b0%8f-drawsizetext">
												 绘制裁切框大小 drawSizeText
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e8%a3%81%e5%88%87%e6%a1%86%e7%9a%84%e7%a7%bb%e5%8a%a8">
												 裁切框的移动
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#mousepressevent">
												 mousePressEvent
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#mousemoveevent">
												 mouseMoveEvent
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#mousereleaseevent">
												 mouseReleaseEvent
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#handlemove">
												 handleMove
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%94%be%e7%bc%a9">
												 放缩
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%94%be%e7%bc%a9%e7%9a%84%e9%bc%a0%e6%a0%87%e6%a0%b7%e5%bc%8f">
												 放缩的鼠标样式
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%94%be%e7%bc%a9%e9%80%bb%e8%be%91">
												 放缩逻辑
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bb%a5%e5%90%91%e4%b8%8a%e4%b8%ba%e4%be%8b-handleresizeup">
												 以向上为例 handleResizeUp
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bb%a5%e5%8f%b3%e4%b8%8a%e4%b8%ba%e4%be%8b-handleresizerighttop">
												 以右上为例 handleResizeRightTop
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e7%bb%93%e5%90%88%e9%94%ae%e7%9b%98%e6%8c%89%e9%94%ae%e6%94%be%e7%bc%a9">
												 结合键盘按键放缩
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e9%9c%80%e8%a6%81%e4%bc%98%e5%8c%96%e7%9a%84%e5%9c%b0%e6%96%b9">
												 需要优化的地方
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%9b%be%e7%89%87%e5%b0%ba%e5%af%b8%e8%bf%87%e5%a4%a7">
												 图片尺寸过大
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e8%ae%a1%e7%ae%97%e6%94%be%e7%bc%a9%e5%90%8e%e7%9a%84%e5%87%a0%e4%bd%95%e5%bd%a2%e7%8a%b6%e7%9a%84%e5%9d%90%e6%a0%87">
												 计算放缩后的几何形状的坐标
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bb%a3%e7%a0%81%e5%9c%b0%e5%9d%80">
												 代码地址
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 

				</ul>
			</div>
			

		</div>
		
	

    </div>
    


  </main>
  


    
    

<footer class="page-footer text-center font-small mt-4 wow fadeIn">


  
  <div class="pb-2 mt-5 pt-5">
    
      <a href="https://github.com/catcheroftime " target="_blank" rel="noopener"><i class="fab fa-github mr-3" aria-hidden="true"></i></a>    
    
    

    

    

    

    

    


    
        <a href="mailto:buptzhangwei@foxmail.com"><i class="far fa-envelope-open mr-3" aria-hidden="true"></i></a>
    

    

    

  </div>
  

  
  <div class="copyright py-4">
    
    <span>  2016 - 2020 &copy; | Theme <a href='https://github.com/orianna-zzo/AllinOne' target="_blank">AllinOne</a> by <a href='https://github.com/orianna-zzo' target="_blank">Orianna</a>  </span>
  </div>
  

</footer>


    






<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/jquery/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/jquery/jquery.smooth-scroll.min.js"></script>



<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/popper.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/holder.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors-extensions/bootstrap4/bootstrap.js" ></script>

<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/mdb/mdb.min.js"></script>

<script type="text/javascript" src="https://catcheroftime.github.io/js/main.js"></script>



  
  <script src="https://catcheroftime.github.io/js/vendors/highlight.pack.js"> </script>
  <script>hljs.initHighlightingOnLoad();</script>




 
  <script src="https://catcheroftime.github.io/js/vendors/katex/katex.min.js"> </script>
  <script src="https://catcheroftime.github.io/js/vendors/katex/contrib/auto-render.min.js"></script>

  <script>
      document.addEventListener("DOMContentLoaded", function () {
          renderMathInElement(document.body);
      });
  </script>








<script type="text/javascript">
  
  new WOW().init();
</script>




  </body>
</html>