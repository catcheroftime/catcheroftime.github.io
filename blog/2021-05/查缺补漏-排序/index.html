<!DOCTYPE html>
<html lang="zn-Hans">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, maximum-scale=1" />
  <meta name="author" content="败给时间">
  <meta name="description" content="">
  
  <meta property="og:title" content="查缺补漏-排序" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://catcheroftime.github.io/blog/2021-05/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%8E%92%E5%BA%8F/" />
<meta property="article:published_time" content="2021-05-13T00:15:00&#43;08:00"/>
<meta property="article:modified_time" content="2021-05-13T00:15:00&#43;08:00"/>


  <title>
  
       查缺补漏-排序 | 一个懒散的程序猿 
  
  </title>

  <link rel="canonical" href="https://catcheroftime.github.io/blog/2021-05/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E6%8E%92%E5%BA%8F/">

  
  

  
  <link href="https://catcheroftime.github.io/css/vendors-extensions/fontawesome/all.min.css" rel="stylesheet">

  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:300,400,500,600">
  <link href="https://catcheroftime.github.io/css/font.css" rel="stylesheet"> 
    
  
  <link href="https://catcheroftime.github.io/css/vendors/bootstrap4/bootstrap.min.css" rel="stylesheet">
  <link href="https://catcheroftime.github.io/css/vendors-extensions/mdb/mdb.min.css" rel="stylesheet"> 
  <link href="https://catcheroftime.github.io/css/vendors/mdb/style.min.css" rel="stylesheet"> 
  <link href="https://catcheroftime.github.io/css/main.css" rel="stylesheet">


  
  <link rel="shortcut icon"
  
  >


  
  

  <style type="text/css">
      @media (min-width: 800px) and (max-width: 850px) {
              .navbar:not(.top-nav-collapse) {
                  background: #1C2331!important;
              }
          }
  </style>


  
    
    <link rel="stylesheet" href="https://catcheroftime.github.io/js/vendors/katex/katex.min.css">
  
  

  
    
    <link rel="stylesheet" href="https://catcheroftime.github.io/css/vendors/highlight/github-gist.css">
  

</head>

  <body class="bg-light" data-spy="scroll" data-target="#page-scrollspy" data-offset="90">
  
    
    

    
      


<nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
    <div class="container">

      
      <a class="navbar-brand" href="https://catcheroftime.github.io/">
          
        <strong> 败给时间</strong>
      </a>

      
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
        aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      
      <div class="collapse navbar-collapse" id="navbarSupportedContent">

        
        <ul class="navbar-nav mr-auto ">
          <li class="nav-item ">
            <a class="nav-link" href="https://catcheroftime.github.io/">Home</a>
          </li>
             
            <li class="nav-item ">
              <a class="nav-link" href="https://catcheroftime.github.io/blog/" >Blog  </a>
            </li>
          
             
            <li class="nav-item ">
              <a class="nav-link" href="https://catcheroftime.github.io/about/" >About  </a>
            </li>
          
          
        </ul>

      </div>

    </div>
  </nav>
  
 
      
 






<div id="site-header" class="carousel slide carousel-fade" data-ride="carousel" style="height: 18rem;" >  

  
  
  

  
  <div class="carousel-inner" role="listbox">
    
      

        
        <div class="carousel-item active">
          <div class="view" style="background-image: url('https://catcheroftime.github.io/img/header-slides/raw_1515691746.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

              
              
              

            </div>
            

          </div>
        </div>
        
      
    
      

        
        <div class="carousel-item">
          <div class="view" style="background-image: url('https://catcheroftime.github.io/img/header-slides//raw_1515847341.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

            

            </div>
            

          </div>
        </div>
        
      
    

  
  </div>
  

  
  <div class="carousel-content text-center white-text wow fadeIn">
    <div class="row mx-0 headfont mt-3 pt-4">
      
      <div class="col-12 col-sm-5 align-middle">
        <a href="https://catcheroftime.github.io/">
          
        </a>
      </div>
      
      <div class="col-12 col-sm-7 text-left pl-2">
        <a href="https://catcheroftime.github.io/">
          <h1 class="mb-2 h1" style="font-weight: 300;" >
            <strong>一个懒散的程序猿</strong>
          </h1>
        </a>
        

             
        <div class="mt-2" style="font-size: 1rem; color: white;">
            
              <a href="https://github.com/catcheroftime" target="_blank" rel="noopener"><i class="fab fa-github pr-1" aria-hidden="true"></i></a>    
            
            

            

            

            

            
    
            
    
        
            
                <a href="mailto:buptzhangwei@foxmail.com"><i class="far fa-envelope-open pr-1" aria-hidden="true"></i></a>
            
    
            

            
        </div>
      </div>
    </div>
  </div>
  

  
  
  

</div>
  
    

    
  
  <main class="post-main-wrapper">
    
    
    <div class="row">

      

      
      <div class="col-md-10">
      

        
        <div class="z-depth-1  post-wrapper white-bg single-post">

          <div class="post-header text-center" >
  <ul class="post-meta li-x">
    
      
        <li><a href="https://catcheroftime.github.io/categories/algorithm"><i class="fas fa-folder-open pr-1" aria-hidden="true"></i> Algorithm </a></li>
      
    
    
  </ul>

  <div class="px-4 post-heading">查缺补漏-排序</div>

  <ul class="post-meta li-x mt-1">
    
      <li>May 13, 2021</li>
    

    
  </ul>
  

</div>


          <div class="post-content markdown">
            <p>今天突然被朋友问到: 来来来, 快速手写个 <strong>堆排序</strong> 看看?<br />
我: 嗯&hellip;嗯&hellip;嗯??? 好吧, 我只记得好像需要建立一个 <code>最大堆</code>, 然后一个一个取出最大值, 但是 <code>最大堆</code> 的代码又咋写?</p>

<p>那么与其整理一个堆排序, 不如整理所有常见的十种排序算法!<br />
不过这篇文章主要是总结算法的思路以及提供一份 <code>C++</code> 的实现, 起到一个 <strong>助记</strong> 的目的</p>

<ul>
<li><a href="#总览">总览</a></li>
<li><a href="#冒泡排序">冒泡排序</a></li>
<li><a href="#插入排序">插入排序</a></li>
<li><a href="#选择排序">选择排序</a></li>
<li><a href="#堆排序">堆排序</a></li>
<li><a href="#快速排序">快速排序</a></li>
<li><a href="#希尔排序">希尔排序</a></li>
<li><a href="#归并排序">归并排序</a></li>
<li><a href="#计数排序">计数排序</a></li>
<li><a href="#桶排序">桶排序</a></li>
<li><a href="#基数排序">基数排序</a></li>
<li><a href="#小结">小结</a></li>
</ul>

<h2 id="总览">总览</h2>

<table>
<thead>
<tr>
<th align="left">排序算法</th>
<th align="left">平均时间复杂度</th>
<th align="left">最差情况</th>
<th align="left">空间复杂度</th>
<th align="left">排序方式</th>
<th align="left">稳定性</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">冒泡排序</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(1)</td>
<td align="left">In-place</td>
<td align="left">稳定</td>
</tr>

<tr>
<td align="left">插入排序</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(1)</td>
<td align="left">In-place</td>
<td align="left">稳定</td>
</tr>

<tr>
<td align="left">选择排序</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(1)</td>
<td align="left">In-place</td>
<td align="left">不稳定</td>
</tr>

<tr>
<td align="left">堆排序</td>
<td align="left">O(nlogn)</td>
<td align="left">O(nlogn)</td>
<td align="left">O(1)</td>
<td align="left">In-place</td>
<td align="left">不稳定</td>
</tr>

<tr>
<td align="left">快速排序</td>
<td align="left">O(nlogn)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(logn)</td>
<td align="left">In-place</td>
<td align="left">不稳定</td>
</tr>

<tr>
<td align="left">希尔排序</td>
<td align="left">O(nlog<sup>2</sup>n)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(1)</td>
<td align="left">In-place</td>
<td align="left">不稳定</td>
</tr>

<tr>
<td align="left">归并排序</td>
<td align="left">O(nlogn)</td>
<td align="left">O(nlogn)</td>
<td align="left">O(n)</td>
<td align="left">Out-place</td>
<td align="left">稳定</td>
</tr>

<tr>
<td align="left">计数排序</td>
<td align="left">O(n+m)</td>
<td align="left">O(n+m)</td>
<td align="left">O(n+m)</td>
<td align="left">Out-place</td>
<td align="left">稳定</td>
</tr>

<tr>
<td align="left">桶排序</td>
<td align="left">O(n)</td>
<td align="left">O(n)</td>
<td align="left">O(m)</td>
<td align="left">Out-place</td>
<td align="left">稳定</td>
</tr>

<tr>
<td align="left">基数排序</td>
<td align="left">O(k*n)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left"></td>
<td align="left">Out-place</td>
<td align="left">稳定</td>
</tr>
</tbody>
</table>

<ul>
<li>均按从小到大排列</li>
<li><code>k</code> 代表数值中的&rdquo;数位&rdquo;个数</li>
<li><code>n</code> 代表数据规模</li>
<li><code>m</code> 代表数据的最大值减最小值</li>
<li>稳定性：<strong>稳定排序算法</strong> 会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 <strong>R</strong>和 <strong>S</strong>，且在原本的列表中 <strong>R</strong> 出现在 <strong>S</strong> 之前，在排序过的列表中 <strong>R</strong> 也将会是在<strong>S</strong>之前。</li>
</ul>

<p>图表摘自：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</a></p>

<h2 id="冒泡排序">冒泡排序</h2>

<blockquote>
<p>(无序区，有序区)<br />
从无序区通过交换找出最大元素放到有序区前端，直到没有任何一对数字需要比较</p>
</blockquote>

<p>冒泡排序思路：</p>

<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>

<pre><code class="language-C++">// 冒泡排序
void BubbleSort(std::vector&lt;int&gt;&amp; v) {
    int len = v.size();
    for (int i = 0; i &lt; len - 1; ++i)
        for (int j = 0; j &lt; len - 1 - i; ++j)
            if (v[j] &gt; v[j + 1]) 
                std::swap(v[j], v[j + 1]);
}

// 模板实现冒泡排序
template&lt;typename T&gt; //  T 对象需要支持或重载大于 (&gt;) 运算符
void bubble_sort(T arr[], int len) {
    for (int i = 0; i &lt; len - 1; i++)
        for (int j = 0; j &lt; len - 1 - i; j++)
            if (arr[j] &gt; arr[j + 1])
                std::swap(arr[j], arr[j + 1]);
}
</code></pre>

<p>通过一次一次的相邻元素比较，将无序区的大数一步一步移动到有序区</p>

<h2 id="插入排序">插入排序</h2>

<blockquote>
<p>(有序区，无序区)<br />
把无序区的第一个元素插入到有序区的合适的位置。</p>
</blockquote>

<p>插入排序思路：</p>

<ul>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中 <strong>从后向前</strong> 扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ul>

<pre><code class="language-C++">// 插入排序
void InsertSort(std::vector&lt;int&gt;&amp; v)
{
    int len = v.size();
    for (int i = 1; i &lt; len; ++i) {
        int temp = v[i];
        for(int j = i - 1; j &gt;= 0; --j)
        {
            if(v[j] &gt; temp)
            {
                v[j + 1] = v[j];
                v[j] = temp;
            }
            else
                break;
        }
    }
}

// 模板实现
template&lt;typename T&gt;
void InsertSort(T array[], int len) {
    for (int i = 1; i &lt; len; ++i) {
        for (int j = i; j &gt;= 1 &amp;&amp; array[j] &lt; array[j - 1]; --j)
            std::swap(array[j], array[j - 1]);
    }
}
</code></pre>

<p>从无序区取出一个值，将这个值在有序区从后向前的比较直到插入到正确的位置</p>

<h2 id="选择排序">选择排序</h2>

<blockquote>
<p>(有序区，无序区)<br />
在无序区里找一个最小的元素跟在有序区的后面。</p>
</blockquote>

<p>选择排序思路：</p>

<ul>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li>
<li>以此类推，直到所有元素均排序完毕</li>
</ul>

<pre><code class="language-C++">// 选择排序
void SelectionSort(std::vector&lt;int&gt;&amp; v) {
    int min, len = v.size();
    for (int i = 0; i &lt; len - 1; ++i) {
        min = i;
        for (int j = i + 1; j &lt; len; ++j) {
            if (v[j] &lt; v[min]) {    // 标记最小的
                min = j;
            }
        }
        if (i != min)  // 交换到前面
            std::swap(v[i], v[min]);
    }
}

// 模板实现
template&lt;typename T&gt; 
void Selection_Sort(std::vector&lt;T&gt;&amp; arr) {
    int len = arr.size();
    for (int i = 0; i &lt; len - 1; i++) {
        int min = i;
        for (int j = i + 1; j &lt; len; j++)
            if (arr[j] &lt; arr[min])
                min = j;
        if(i != min)
            std::swap(arr[i], arr[min]);
    }
}
</code></pre>

<p>找出无序区的最小值，经过一次交换，移动有序区的最后</p>

<p>不稳定的例子</p>

<pre><code class="language-C++">[5, 8, 5, 2, 9]
// 第一趟就改变了两个 5 的位置
[2, 8, 5, 5, 9]
</code></pre>

<h2 id="堆排序">堆排序</h2>

<blockquote>
<p>(最大堆，有序区)<br />
从堆顶把根卸出来放在有序区之前，再恢复堆。</p>
</blockquote>

<p>以升序排序说明思路:</p>

<ul>
<li>把数组转换成最大堆 (降序的话就是转换成最小堆)</li>
<li>重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。</li>
</ul>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

void max_heapify(int arr[], int start, int end) {
    // 建立父节点指标和子节点指标
    int dad = start;
    int son = dad * 2 + 1;
    while (son &lt;= end) { // 若子节点指标在范围内才做比较
        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比较两个子节点大小，选择最大的
            son++;
        if (arr[dad] &gt; arr[son]) // 如果父节点大于子节点代表调整完毕，直接跳出函数
            return;
        else { // 否则交换父子内容再继续子节点和孙节点比较
            swap(arr[dad], arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(int arr[], int len) {
    // 初始化，i从最后一个父节点开始调整
    for (int i = len / 2 - 1; i &gt;= 0; i--)
        max_heapify(arr, i, len - 1);
    // 先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕
    for (int i = len - 1; i &gt; 0; i--) {
        swap(arr[0], arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}

int main() {
    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    heap_sort(arr, len);
    for (int i = 0; i &lt; len; i++)
        cout &lt;&lt; arr[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>神似选择排序，类似于利用最大堆，找出 “无序区” 中最大值后放入有序区</p>

<p>不稳定的例子</p>

<pre><code class="language-C++">// 输入
[5, 8, 5, 2, 4]
// 创建最大堆
[8, 5, 5, 2, 4]
// 第一次取出最大值
[4, 5, 5, 2, 8]
// 维护最大堆
[5, 4, 5, 2, 8]
// 5 和 2 需要交换
[2, 4, 5, 5, 8]
</code></pre>

<h2 id="快速排序">快速排序</h2>

<blockquote>
<p>(小数，基准元素，大数)<br />
在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</p>
</blockquote>

<p>快速排序思路：</p>

<ul>
<li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li>
</ul>

<pre><code class="language-C++">// 模板实现快速排序（递归）
template &lt;typename T&gt;
void quick_sort_recursive(T arr[], int start, int end) {
    if (start &gt;= end)
        return;
    T mid = arr[end];
    int left = start, right = end - 1;
    while (left &lt; right) {
        while (arr[left] &lt; mid &amp;&amp; left &lt; right)
            left++;
        while (arr[right] &gt;= mid &amp;&amp; left &lt; right)
            right--;
        std::swap(arr[left], arr[right]);
    }
    if (arr[left] &gt;= arr[end])
        std::swap(arr[left], arr[end]);
    else
        left++;
    quick_sort_recursive(arr, start, left - 1);
    quick_sort_recursive(arr, left + 1, end);
}
template &lt;typename T&gt; //整数或浮点数皆可使用,若要使用class时必须重载&quot;小于&quot;(&lt;)、&quot;大于&quot;(&gt;)、&quot;不小于&quot;(&gt;=)的运算符
void quick_sort(T arr[], int len) {
    quick_sort_recursive(arr, 0, len - 1);
}
</code></pre>

<pre><code class="language-C++">// 模板实现快速排序（迭代）
struct Range {
    int start, end;
    Range(int s = 0, int e = 0) {start = s, end = e;}
};

template&lt;typename T&gt; 
void quick_sort(T arr[], const int len) {
    if (len &lt;= 0) return; //避免len等于负值时错误
    //r[]模拟堆迭,p为数量,r[p++]为push,r[--p]为pop且取得元素
    Range r[len]; int p = 0;
    r[p++] = Range(0, len - 1);
    while (p) {
        Range range = r[--p];
        if(range.start &gt;= range.end) continue;
        T mid = arr[range.end];
        int left = range.start, right = range.end - 1;
        while (left &lt; right) {
            while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;
            while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;
            std::swap(arr[left], arr[right]);
        }
        if (arr[left] &gt;= arr[range.end])
            std::swap(arr[left], arr[range.end]);
        else
            left++;
        r[p++] = Range(range.start, left - 1);
        r[p++] = Range(left + 1, range.end);
    }
}
</code></pre>

<p>一趟找出基准所在的正确位置，然后递归基准左右2侧其他元素</p>

<p>不稳定的例子</p>

<pre><code class="language-C++">// 选择最后一个数 4 作为基准
[5, 8, 5, 2, 4]
// left 指向的 5 和 right 指向的 2 需要交换
[2, 8, 5, 5, 4]
</code></pre>

<h2 id="希尔排序">希尔排序</h2>

<blockquote>
<p>每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是 1。</p>
</blockquote>

<p>希尔排序的实质就是 <strong>分组</strong> 插入排序，是插入排序的一种更高效的改进版本。</p>

<p>希尔排序思路：</p>

<ul>
<li>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序</li>
<li>依次 <strong>缩减增量</strong> 再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</li>
</ul>

<pre><code class="language-C++">template&lt;typename T&gt;
void shell_sort(T array[], int length) {
    int h = 1;
    while (h &lt; length / 3) {
        h = 3 * h + 1;
    }
    while (h &gt;= 1) {
        for (int i = h; i &lt; length; i++) {
            for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h)
                std::swap(array[j], array[j - h]);
        }
        h = h / 3;
    }
}
</code></pre>

<p>不稳定的例子</p>

<pre><code class="language-C++">// 基础输入
[5, 8, 5, 2, 4, 6]
// 初始步长为 4 
// 第一组 [5,4],  第二组 [8,6],  第三组 [5], 第四组 [2]
// 第一组第二组按照插入排序思路交换位置
[4, 6, 5, 2, 5, 8]
</code></pre>

<p>按照一定间隔分组，分组内的最后一个元素按照插入排序的思路从后向前插入到合适位置，然后逐渐缩小间隔</p>

<h2 id="归并排序">归并排序</h2>

<blockquote>
<p>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。可从上到下或从下到上进行。</p>
</blockquote>

<p>递归法（Top-down）</p>

<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>

<pre><code class="language-C++">void Merge(vector&lt;int&gt; &amp;Array, int front, int mid, int end) {
    // preconditions:
    // Array[front...mid] is sorted
    // Array[mid+1 ... end] is sorted
    // Copy Array[front ... mid] to LeftSubArray
    // Copy Array[mid+1 ... end] to RightSubArray
    vector&lt;int&gt; LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);
    vector&lt;int&gt; RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);
    int idxLeft = 0, idxRight = 0;
    LeftSubArray.insert(LeftSubArray.end(), numeric_limits&lt;int&gt;::max());
    RightSubArray.insert(RightSubArray.end(), numeric_limits&lt;int&gt;::max());
    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]
    for (int i = front; i &lt;= end; i++) {
        if (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) {
            Array[i] = LeftSubArray[idxLeft];
            idxLeft++;
        } else {
            Array[i] = RightSubArray[idxRight];
            idxRight++;
        }
    }
}

void MergeSort(vector&lt;int&gt; &amp;Array, int front, int end) {
    if (front &gt;= end)
        return;
    int mid = front + (end - front) / 2;
    MergeSort(Array, front, mid);
    MergeSort(Array, mid + 1, end);
    Merge(Array, front, mid, end);
}
</code></pre>

<p>迭代法（Bottom-up）<br />
原理如下（假设序列共有 <math> n </math> 个元素）：</p>

<ul>
<li>将序列每相邻两个数字进行归并操作，形成 <math>ceil(n/2)</math> 个序列，排序后每个序列包含两/一个元素</li>
<li>若此时序列数不是1个则将上述序列再次归并，形成 <math>ceil(n/4)</math> 个序列，每个序列包含四/三个元素</li>
<li>重复步骤2，直到所有元素排序完毕，即序列数为1</li>
</ul>

<pre><code class="language-C++">template&lt;typename T&gt; // 整数或浮点数皆可使用,若要使用 class 时必须重载&quot;小于&quot;(&lt;)的运算符
void merge_sort(T arr[], int len) {
    T *a = arr;
    T *b = new T[len];
    for (int seg = 1; seg &lt; len; seg += seg) {
        for (int start = 0; start &lt; len; start += seg + seg) {
            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)
                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];
            while (start1 &lt; end1)
                b[k++] = a[start1++];
            while (start2 &lt; end2)
                b[k++] = a[start2++];
        }
        // 交换指针，将这一次合并的结果 b 执行下一次 a 数组中，下一次保存结果指向这一次的 a
        T *temp = a;
        a = b;
        b = temp;
    }
    // 因为交换过的指针，最后的结果可能在 `b` 或者在 `a` 上，需要做一次额外判断和赋值
    if (a != arr) {
        for (int i = 0; i &lt; len; i++)
            b[i] = a[i];
        b = a;
    }
    delete[] b;
}
</code></pre>

<p>从两个排好序的序列中取出各自最小的数比较，取出更小值放入新的队列，然后重新从这两个序列中取最小数比较</p>

<h2 id="计数排序">计数排序</h2>

<blockquote>
<p>统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
</blockquote>

<p>计数排序思路：</p>

<ul>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1</li>
</ul>

<pre><code class="language-C++">// 计数排序
void CountSort(vector&lt;int&gt;&amp; vecRaw, vector&lt;int&gt;&amp; vecObj)
{
    // 确保待排序容器非空
    if (vecRaw.size() == 0)
        return;

    // 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小
    int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1;
    vector&lt;int&gt; vecCount(vecCountLength, 0);

    // 统计每个键值出现的次数
    for (int i = 0; i &lt; vecRaw.size(); i++)
        vecCount[vecRaw[i]]++;

    // 后面的键值出现的位置为前面所有键值出现的次数之和
    for (int i = 1; i &lt; vecCountLength; i++)
        vecCount[i] += vecCount[i - 1];

    // 将键值放到目标位置
    for (int i = vecRaw.size(); i &gt; 0; i--) // 此处逆序是为了保持相同键值的稳定性
        vecObj[--vecCount[vecRaw[i - 1]]] = vecRaw[i - 1];
}
</code></pre>

<p>很巧妙的思路，用一个新的数组的下标来表示值，对应位置保存存在几个值，计算次数和是为了得到这个数在新数值中的位置，反向填充保持键值的稳定性</p>

<h2 id="桶排序">桶排序</h2>

<blockquote>
<p>将值为 i 的元素放入i号桶，最后依次把桶里的元素倒出来。</p>
</blockquote>

<p>桶排序思路：</p>

<ul>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ul>

<pre><code class="language-C++">// 假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序。然后把各个桶中的数据合并。
const int BUCKET_NUM = 10;

struct ListNode{
    explicit ListNode(int i=0):mData(i),mNext(NULL){}
    ListNode* mNext;
    int mData;
};

ListNode* insert(ListNode* head,int val){
    ListNode dummyNode;
    ListNode *newNode = new ListNode(val);
    ListNode *pre,*curr;
    dummyNode.mNext = head;
    pre = &amp;dummyNode;
    curr = head;
    while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val){
        pre = curr;
        curr = curr-&gt;mNext;
    }
    newNode-&gt;mNext = curr;
    pre-&gt;mNext = newNode;
    return dummyNode.mNext;
}


ListNode* Merge(ListNode *head1,ListNode *head2){
    ListNode dummyNode;
    ListNode *dummy = &amp;dummyNode;
    while(NULL!=head1 &amp;&amp; NULL!=head2){
        if(head1-&gt;mData &lt;= head2-&gt;mData){
            dummy-&gt;mNext = head1;
            head1 = head1-&gt;mNext;
        }else{
            dummy-&gt;mNext = head2;
            head2 = head2-&gt;mNext;
        }
        dummy = dummy-&gt;mNext;
    }
    if(NULL!=head1) dummy-&gt;mNext = head1;
    if(NULL!=head2) dummy-&gt;mNext = head2;
    
    return dummyNode.mNext;
}

void BucketSort(int n,int arr[]){
    vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0));
    for(int i=0;i&lt;n;++i){
        int index = arr[i]/BUCKET_NUM;
        ListNode *head = buckets.at(index);
        buckets.at(index) = insert(head,arr[i]);
    }
    ListNode *head = buckets.at(0);
    for(int i=1;i&lt;BUCKET_NUM;++i){
        head = Merge(head,buckets.at(i));
    }
    for(int i=0;i&lt;n;++i){
        arr[i] = head-&gt;mData;
        head = head-&gt;mNext;
    }
}
</code></pre>

<h2 id="基数排序">基数排序</h2>

<blockquote>
<p>一种多关键字的排序算法，可用桶排序实现。</p>
</blockquote>

<p>是一种 <strong>非比较型整数</strong> 排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</p>

<p>基数排序思路：</p>

<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li>
<li>从最低位开始，依次进行一次排序。</li>
<li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>
</ul>

<pre><code class="language-C++">int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];        ///&lt; 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i &lt; n; ++i)
    {
        if (maxData &lt; data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData &gt;= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
}

void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i &lt;= d; i++) //进行d次排序
    {
        for(j = 0; j &lt; 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j &lt; n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j &lt; 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j &gt;= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j &lt; n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
</code></pre>

<h2 id="小结">小结</h2>

<p>每一种算法涉及的知识都很多，我这里总结更大的目的是 <strong>助记</strong> ，也可以时不时再回味一下代码，再思考一下实现思路，更强化记忆~</p>
          </div>

          
          <div class="row">
            <div class="col-md-8">
            
              <div class="mb-5">
                
<div class="li-x div-x post-meta">
  <li class="pr-0"><a href="https://catcheroftime.github.io/tags/"><i class="fas fa-tags"></i></a></li>
  <div class="tags-sm">
    
      <li><a href="https://catcheroftime.github.io/tags/algorithm" role="button">Algorithm </a></li>
      
    
  </div>
</div>
              </div>
            
            </div>
            
          </div>
          

          
          <div class="row pt-3">
            <div class="col-md-6">
              
                <a href=https://catcheroftime.github.io/blog/2021-05/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/ class="post-meta">
                  <div class="pt-2 pb-5 d-flex">
                    <i class="fas fa-angle-left text-grey font-weight-bold mr-2 active-color"></i>
                    <span>迭代器模式</span>
                  </div>
                </a>
              
            </div>
            
            <div class="col-md-6 text-right" >
              
                <a href=https://catcheroftime.github.io/blog/2021-05/%E5%85%8D%E8%B4%B9%E6%89%BE%E7%94%B5%E5%AD%90%E4%B9%A6%E7%9A%84%E7%BD%91%E7%AB%99%E6%80%BB%E7%BB%93/ class="post-meta">
                  <div class="pt-2 pb-5 flex-reverse">
                    <i class="fas fa-angle-right text-grey font-weight-bold ml-2 active-color"></i>
                    <span>免费找电子书的网站总结</span>
                  </div>
                </a>
              
            </div>
          </div>

          

        </div>
        

      </div>
      

      
	
	
	
	
		
		
		
	

		
		<div class="col-md-2 pl-0">

			
			<div id="page-scrollspy" class="toc-nav">
				
				<ul class="nav nav-pills ml-0">
					
					<li class="nav-item pb-3 text-center">
						<span class="font-weight-bold mb-2">- CATALOG - </span>
					</li>

					
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%80%bb%e8%a7%88">
												 总览
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f">
												 冒泡排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">
												 插入排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">
												 选择排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%a0%86%e6%8e%92%e5%ba%8f">
												 堆排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">
												 快速排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f">
												 希尔排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">
												 归并排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f">
												 计数排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%a1%b6%e6%8e%92%e5%ba%8f">
												 桶排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f">
												 基数排序
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%b0%8f%e7%bb%93">
												 小结
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 

				</ul>
			</div>
			

		</div>
		
	

    </div>
    


  </main>
  


    
    

<footer class="page-footer text-center font-small mt-4 wow fadeIn">


  
  <div class="pb-2 mt-5 pt-5">
    
      <a href="https://github.com/catcheroftime " target="_blank" rel="noopener"><i class="fab fa-github mr-3" aria-hidden="true"></i></a>    
    
    

    

    

    

    

    


    
        <a href="mailto:buptzhangwei@foxmail.com"><i class="far fa-envelope-open mr-3" aria-hidden="true"></i></a>
    

    

    

  </div>
  

  
  <div class="copyright py-4">
    
    <span>  2016 - 2021 &copy; | Theme <a href='https://github.com/orianna-zzo/AllinOne' target="_blank">AllinOne</a> by <a href='https://github.com/orianna-zzo' target="_blank">Orianna</a>  </span>
  </div>
  

</footer>


    






<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/jquery/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/jquery/jquery.smooth-scroll.min.js"></script>



<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/popper.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/holder.min.js"></script>
<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors-extensions/bootstrap4/bootstrap.js" ></script>

<script type="text/javascript" src="https://catcheroftime.github.io/js/vendors/mdb/mdb.min.js"></script>

<script type="text/javascript" src="https://catcheroftime.github.io/js/main.js"></script>



  
  <script src="https://catcheroftime.github.io/js/vendors/highlight.pack.js"> </script>
  <script>hljs.initHighlightingOnLoad();</script>




 
  <script src="https://catcheroftime.github.io/js/vendors/katex/katex.min.js"> </script>
  <script src="https://catcheroftime.github.io/js/vendors/katex/contrib/auto-render.min.js"></script>

  <script>
      document.addEventListener("DOMContentLoaded", function () {
          renderMathInElement(document.body);
      });
  </script>








<script type="text/javascript">
  
  new WOW().init();
</script>




  </body>
</html>