<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev Book on 一个懒散的程序猿</title>
    <link>https://catcheroftime.github.io/categories/dev-book/</link>
    <description>Recent content in Dev Book on 一个懒散的程序猿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Sat, 14 Aug 2021 21:02:00 +0800</lastBuildDate>
    
	<atom:link href="https://catcheroftime.github.io/categories/dev-book/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Effective C&#43;&#43; 总览</title>
      <link>https://catcheroftime.github.io/blog/2021-08/effective-c-%E6%80%BB%E8%A7%88/</link>
      <pubDate>Sat, 14 Aug 2021 21:02:00 +0800</pubDate>
      
      <guid>https://catcheroftime.github.io/blog/2021-08/effective-c-%E6%80%BB%E8%A7%88/</guid>
      <description>开个新坑，做一做自己看书的笔记 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、co</description>
    </item>
    
    <item>
      <title>More Effective C&#43;&#43; 总览</title>
      <link>https://catcheroftime.github.io/blog/2021-08/more-effective-c-%E6%80%BB%E8%A7%88/</link>
      <pubDate>Sat, 14 Aug 2021 21:02:00 +0800</pubDate>
      
      <guid>https://catcheroftime.github.io/blog/2021-08/more-effective-c-%E6%80%BB%E8%A7%88/</guid>
      <description>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers） 最好使用 C++ 转型操作符（static_cast、const_cast、dynamic_cast、reinterpret_cast） 绝不要以多态（polymorphically）方式处理数组（多</description>
    </item>
    
    <item>
      <title>shell 使用总结</title>
      <link>https://catcheroftime.github.io/blog/2019-10/shell-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 29 Oct 2019 18:22:00 +0800</pubDate>
      
      <guid>https://catcheroftime.github.io/blog/2019-10/shell-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;在 &lt;code&gt;ubuntu&lt;/code&gt; 下部署服务的时候，经常出现大量反复的操作，而且还容易出错，所有刚好可以通过 &lt;code&gt;shell&lt;/code&gt; 脚本的形式 将这个部分完美替代了&lt;br&gt;在写脚本过程中，对自己使用到一些知识进行了简单的总结&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>程序员的自我修养-链接装载与库</title>
      <link>https://catcheroftime.github.io/blog/2019-10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/</link>
      <pubDate>Sat, 12 Oct 2019 11:02:00 +0800</pubDate>
      
      <guid>https://catcheroftime.github.io/blog/2019-10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/</guid>
      <description>&lt;p&gt;每次在用 &lt;code&gt;QT&lt;/code&gt; 点击编译总是很好奇编译器具体对我的代码做了哪些操作，同时也好奇动态库，静态库等在程序运行中是怎么被程序调用的，于是学习一波 《程序员的自我修养-链接装载与库》，通过这篇博客打卡&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>